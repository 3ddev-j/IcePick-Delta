diff -rupN ./Marlin/Marlin/Configuration_adv.h ./Marlin_latest_MOD/Marlin/Configuration_adv.h
--- ./Marlin/Marlin/Configuration_adv.h	2014-11-29 01:24:30.384865000 +1300
+++ ./Marlin_latest_MOD/Marlin/Configuration_adv.h	2014-11-29 01:28:17.086149976 +1300
@@ -245,7 +245,7 @@
 
 // If defined the movements slow down when the look ahead buffer is only half full
 // (don't use SLOWDOWN with DELTA because DELTA generates hundreds of segments per second)
-//#define SLOWDOWN
+#define SLOWDOWN
 
 // Frequency limit
 // See nophead's blog for more info
diff -rupN ./Marlin/Marlin/Configuration.h ./Marlin_latest_MOD/Marlin/Configuration.h
--- ./Marlin/Marlin/Configuration.h	2014-11-29 01:24:30.384865000 +1300
+++ ./Marlin_latest_MOD/Marlin/Configuration.h	2014-11-29 01:34:13.941824109 +1300
@@ -24,7 +24,7 @@
 #define SERIAL_PORT 0
 
 // This determines the communication speed of the printer
-#define BAUDRATE 250000
+#define BAUDRATE 115200
 
 // This enables the serial port associated to the Bluetooth interface
 //#define BTENABLED              // Enable BT interface on AT90USB devices
@@ -74,9 +74,9 @@
 // 88 = 5DPrint D8 Driver Board
 // 999 = Leapfrog
 
-#ifndef MOTHERBOARD
+//#ifndef MOTHERBOARD
 #define MOTHERBOARD 33
-#endif
+//#endif
 
 // Define this to set a custom name for your generic Mendel,
 // #define CUSTOM_MENDEL_NAME "This Mendel"
@@ -103,27 +103,65 @@
 // Enable DELTA kinematics and most of the default configuration for Deltas
 #define DELTA
 
+
+// NOTE NB all values for DELTA_* values MUST be floating point, so always have a decimal point in them
+
+//// Center-to-center distance of the holes in the diagonal push rods.
+//#define DELTA_DIAGONAL_ROD 250.0 // mm
+//
+//// Horizontal offset from middle of printer to smooth rod center.
+//#define DELTA_SMOOTH_ROD_OFFSET 175.0 // mm
+//
+//// Horizontal offset of the universal joints on the end effector.
+//#define DELTA_EFFECTOR_OFFSET 33.0 // mm
+//
+//// Horizontal offset of the universal joints on the carriages.
+//#define DELTA_CARRIAGE_OFFSET 18.0 // mm
+
+// Effective horizontal distance bridged by diagonal push rods.
+// Irrelevant for non linear deltas, but the rest of the code still expect this value to exist
+#define DELTA_RADIUS 20 //(DELTA_SMOOTH_ROD_OFFSET-DELTA_EFFECTOR_OFFSET-DELTA_CARRIAGE_OFFSET)
+
+
+
 // Make delta curves from many straight lines (linear interpolation).
 // This is a trade-off between visible corners (not enough segments)
 // and processor overload (too many expensive sqrt calls).
 #define DELTA_SEGMENTS_PER_SECOND 200
 
-// NOTE NB all values for DELTA_* values MUST be floating point, so always have a decimal point in them
+// end effector side length (length of the side of the equilateral triangle)
+#define END_EFFECTOR_SIDE 70.0
+
+// base side length (length of the side of the equilateral triangle)
+#define BASE_SIDE 450.33
 
 // Center-to-center distance of the holes in the diagonal push rods.
-#define DELTA_DIAGONAL_ROD 250.0 // mm
+#define DELTA_DIAGONAL_ROD 300.0
 
-// Horizontal offset from middle of printer to smooth rod center.
-#define DELTA_SMOOTH_ROD_OFFSET 175.0 // mm
+// actuator arm length
+#define DELTA_ARM_LENGTH 160.0
 
-// Horizontal offset of the universal joints on the end effector.
-#define DELTA_EFFECTOR_OFFSET 33.0 // mm
 
-// Horizontal offset of the universal joints on the carriages.
-#define DELTA_CARRIAGE_OFFSET 18.0 // mm
+#define PULLEY_MOUNT_HEIGHT 65.0         // height from pulley axle centre to mounting plate
+#define END_EFFECTOR_TO_MOUNTPLATE 208.0 // distance from top end effector to mounting plate
+
+
+#define DELTA_HOME_POS MANUAL_Z_HOME_POS - 143 //269 is the distance from the end effector to the rotating shafts at the home position
+
+//#define  DELTA_HOME_POS = (END_EFFECTOR_TO_MOUNTPLATE - PULLEY_MOUNT_HEIGHT) 
+
+// number of teeth on the worm and wheel
+#define WHEEL_TEETH 218
+
+// trigonometric constants
+#define DELTA_SQRT3 1.732050807
+#define DELTA_PI 3.141592653; // PI
+#define DELTA_SIN120 DELTA_SQRT3/2.0
+#define DELTA_COS120 -0.5;
+#define DELTA_TAN60 DELTA_SQRT3;
+#define DELTA_SIN30 0.5;
+#define DELTA_TAN30 1/DELTA_SQRT3;
 
-// Effective horizontal distance bridged by diagonal push rods.
-#define DELTA_RADIUS (DELTA_SMOOTH_ROD_OFFSET-DELTA_EFFECTOR_OFFSET-DELTA_CARRIAGE_OFFSET)
 
 //===========================================================================
 //=============================Thermal Settings  ============================
@@ -163,8 +201,8 @@
 // 147 is Pt100 with 4k7 pullup
 // 110 is Pt100 with 1k pullup (non standard)
 
-#define TEMP_SENSOR_0 -1
-#define TEMP_SENSOR_1 -1
+#define TEMP_SENSOR_0 1
+#define TEMP_SENSOR_1 0
 #define TEMP_SENSOR_2 0
 #define TEMP_SENSOR_BED 0
 
@@ -188,9 +226,9 @@
 // When temperature exceeds max temp, your heater will be switched off.
 // This feature exists to protect your hotend from overheating accidentally, but *NOT* from thermistor short/failure!
 // You should use MINTEMP for thermistor short/failure protection.
-#define HEATER_0_MAXTEMP 275
-#define HEATER_1_MAXTEMP 275
-#define HEATER_2_MAXTEMP 275
+#define HEATER_0_MAXTEMP 245
+#define HEATER_1_MAXTEMP 245
+#define HEATER_2_MAXTEMP 245
 #define BED_MAXTEMP 150
 
 // If your bed has low resistance e.g. .6 ohm and throws the fuse you can duty cycle it to reduce the
@@ -205,8 +243,8 @@
 // PID settings:
 // Comment the following line to disable PID and enable bang-bang.
 #define PIDTEMP
-#define BANG_MAX 255 // limits current to nozzle while in bang-bang mode; 255=full current
-#define PID_MAX 255 // limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 255=full current
+#define BANG_MAX 170 // limits current to nozzle while in bang-bang mode; 255=full current
+#define PID_MAX 170 // limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 255=full current
 #ifdef PIDTEMP
   //#define PID_DEBUG // Sends debug data to the serial port.
   //#define PID_OPENLOOP 1 // Puts PID in open loop. M104/M140 sets the output power from 0 to PID_MAX
@@ -218,19 +256,16 @@
 
 // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
 // Ultimaker
-    #define  DEFAULT_Kp 22.2
-    #define  DEFAULT_Ki 1.08
-    #define  DEFAULT_Kd 114
-
-// MakerGear
-//    #define  DEFAULT_Kp 7.0
-//    #define  DEFAULT_Ki 0.1
-//    #define  DEFAULT_Kd 12
-
-// Mendel Parts V9 on 12V
-//    #define  DEFAULT_Kp 63.0
-//    #define  DEFAULT_Ki 2.25
-//    #define  DEFAULT_Kd 440
+    //#define  DEFAULT_Kp 11.58
+    //#define  DEFAULT_Ki 1.24
+    //#define  DEFAULT_Kd 27.03
+    
+// My J-head hotend
+    #define  DEFAULT_Kp 12.47
+    #define  DEFAULT_Ki 1.44
+    #define  DEFAULT_Kd 27.08
+
+
 #endif // PIDTEMP
 
 // Bed Temperature Control
@@ -253,21 +288,15 @@
 // so you shouldn't use it unless you are OK with PWM on your bed.  (see the comment on enabling PIDTEMPBED)
 #define MAX_BED_POWER 255 // limits duty cycle to bed; 255=full current
 
+
+
+
 #ifdef PIDTEMPBED
-//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
-//from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
+// pid bed settings
     #define  DEFAULT_bedKp 10.00
-    #define  DEFAULT_bedKi .023
+    #define  DEFAULT_bedKi 1.023
     #define  DEFAULT_bedKd 305.4
-
-//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
-//from pidautotune
-//    #define  DEFAULT_bedKp 97.1
-//    #define  DEFAULT_bedKi 1.41
-//    #define  DEFAULT_bedKd 1675.16
-
-// FIND YOUR OWN: "M303 E-1 C8 S90" to run autotune on the bed at 90 degreesC for 8 cycles.
-#endif // PIDTEMPBED
+#endif
 
 
 
@@ -330,33 +359,33 @@ your extruder heater takes 2 minutes to
 
 #ifndef ENDSTOPPULLUPS
   // fine endstop settings: Individual pullups. will be ignored if ENDSTOPPULLUPS is defined
-  // #define ENDSTOPPULLUP_XMAX
-  // #define ENDSTOPPULLUP_YMAX
-  // #define ENDSTOPPULLUP_ZMAX
+   #define ENDSTOPPULLUP_XMAX
+   #define ENDSTOPPULLUP_YMAX
+   #define ENDSTOPPULLUP_ZMAX
   // #define ENDSTOPPULLUP_XMIN
   // #define ENDSTOPPULLUP_YMIN
-  // #define ENDSTOPPULLUP_ZMIN
+   #define ENDSTOPPULLUP_ZMIN
 #endif
 
 #ifdef ENDSTOPPULLUPS
   #define ENDSTOPPULLUP_XMAX
   #define ENDSTOPPULLUP_YMAX
   #define ENDSTOPPULLUP_ZMAX
-  #define ENDSTOPPULLUP_XMIN
-  #define ENDSTOPPULLUP_YMIN
+  //#define ENDSTOPPULLUP_XMIN
+  //#define ENDSTOPPULLUP_YMIN
   #define ENDSTOPPULLUP_ZMIN
 #endif
 
 // The pullups are needed if you directly connect a mechanical endswitch between the signal and ground pins.
-const bool X_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool Y_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool Z_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool X_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool Y_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool X_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool Y_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool Z_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool X_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool Y_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool Z_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
 //#define DISABLE_MAX_ENDSTOPS
 // Deltas never have min endstops
-#define DISABLE_MIN_ENDSTOPS
+//#define DISABLE_MIN_ENDSTOPS
 // Disable max endstops for compatibility with endstop checking routine
 #if defined(COREXY) && !defined(DISABLE_MAX_ENDSTOPS)
   #define DISABLE_MAX_ENDSTOPS
@@ -379,7 +408,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
 #define INVERT_Y_DIR false
 #define INVERT_Z_DIR false
 
-#define INVERT_E0_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false
+#define INVERT_E0_DIR true   // for direct drive extruder v9 set to true, for geared extruder set to false
 #define INVERT_E1_DIR false    // for direct drive extruder v9 set to true, for geared extruder set to false
 #define INVERT_E2_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false
 
@@ -406,8 +435,8 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
 #define Z_MAX_LENGTH (Z_MAX_POS - Z_MIN_POS)
 //============================= Bed Auto Leveling ===========================
 
-//#define ENABLE_AUTO_BED_LEVELING // Delete the comment to enable (remove // at the start of the line)
-#define Z_PROBE_REPEATABILITY_TEST  // If not commented out, Z-Probe Repeatability test will be included if Auto Bed Leveling is Enabled.
+#define ENABLE_AUTO_BED_LEVELING // Delete the comment to enable (remove // at the start of the line)
+//#define Z_PROBE_REPEATABILITY_TEST  // If not commented out, Z-Probe Repeatability test will be included if Auto Bed Leveling is Enabled.
 
 #ifdef ENABLE_AUTO_BED_LEVELING
 
@@ -438,7 +467,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
 
      // set the number of grid points per dimension
      // I wouldn't see a reason to go above 3 (=9 probing points on the bed)
-    #define AUTO_BED_LEVELING_GRID_POINTS 2
+    #define AUTO_BED_LEVELING_GRID_POINTS 3
 
 
   #else  // not AUTO_BED_LEVELING_GRID
@@ -508,21 +537,21 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
 // For deltabots this means top and center of the Cartesian print volume.
 #define MANUAL_X_HOME_POS 0
 #define MANUAL_Y_HOME_POS 0
-#define MANUAL_Z_HOME_POS 250 // For delta: Distance between nozzle and print surface after homing.
+#define MANUAL_Z_HOME_POS 170 // For delta: Distance between nozzle and print surface after homing.
 
 //// MOVEMENT SETTINGS
 #define NUM_AXIS 4 // The axis order in all axis related arrays is X, Y, Z, E
 
 // delta homing speeds must be the same on xyz
-#define HOMING_FEEDRATE {200*60, 200*60, 200*60, 0}  // set the homing speeds (mm/min)
+#define HOMING_FEEDRATE {100*60, 100*60, 100*60, 0}  // set the homing speeds (mm/min)
 
 // default settings
 // delta speeds must be the same on xyz
-#define DEFAULT_AXIS_STEPS_PER_UNIT   {80, 80, 80, 760*1.1}  // default steps per unit for Kossel (GT2, 20 tooth)
-#define DEFAULT_MAX_FEEDRATE          {500, 500, 500, 25}    // (mm/sec)
+#define DEFAULT_AXIS_STEPS_PER_UNIT   {80, 80, 80, 610.2}  // default steps per unit for Kossel (GT2, 20 tooth)
+#define DEFAULT_MAX_FEEDRATE          {200, 200, 200, 25}    // (mm/sec)
 #define DEFAULT_MAX_ACCELERATION      {9000,9000,9000,10000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for skeinforge 40+, for older versions raise them a lot.
 
-#define DEFAULT_ACCELERATION          3000    // X, Y, Z and E max acceleration in mm/s^2 for printing moves
+#define DEFAULT_ACCELERATION          500    // X, Y, Z and E max acceleration in mm/s^2 for printing moves
 #define DEFAULT_RETRACT_ACCELERATION  3000   // X, Y, Z and E max acceleration in mm/s^2 for retracts
 
 // Offset of the extruders (uncomment if using more than one and relying on firmware to position when changing).
@@ -533,8 +562,8 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
 
 // The speed change that does not require acceleration (i.e. the software might assume it can be done instantaneously)
 #define DEFAULT_XYJERK                20.0    // (mm/sec)
-#define DEFAULT_ZJERK                 20.0    // (mm/sec) Must be same as XY for delta
-#define DEFAULT_EJERK                 5.0    // (mm/sec)
+#define DEFAULT_ZJERK       DEFAULT_XYJERK    // same as xY jerk for delta
+#define DEFAULT_EJERK                  5.0    // (mm/sec)
 
 //===========================================================================
 //=============================Additional Features===========================
diff -rupN ./Marlin/Marlin/language.h ./Marlin_latest_MOD/Marlin/language.h
--- ./Marlin/Marlin/language.h	2014-11-29 01:24:30.384865505 +1300
+++ ./Marlin_latest_MOD/Marlin/language.h	2014-11-17 02:57:31.000000000 +1300
@@ -665,7 +665,7 @@
 	#define MSG_AUTOSTART " Autostart"
 	#define MSG_DISABLE_STEPPERS "Apagar motores"
 	#define MSG_AUTO_HOME "Llevar al origen"
-	#define MSG_SET_HOME_OFFSETS "Ajustar offsets"
+	#define MSG_SET_HOME_OFFSETS "Set home offsets"
 	#define MSG_SET_ORIGIN "Establecer cero"
 	#define MSG_PREHEAT_PLA "Precalentar PLA"
 	#define MSG_PREHEAT_PLA0 "Precalentar PLA 1"
@@ -682,8 +682,8 @@
 	#define MSG_PREHEAT_ABS_BEDONLY "Precal. ABS Base"
 	#define MSG_PREHEAT_ABS_SETTINGS "Ajustar temp. ABS"
 	#define MSG_COOLDOWN "Enfriar"
-	#define MSG_SWITCH_PS_ON "Encender"
-	#define MSG_SWITCH_PS_OFF "Apagar"
+	#define MSG_SWITCH_PS_ON "Switch Power On"
+	#define MSG_SWITCH_PS_OFF "Switch Power Off"
 	#define MSG_EXTRUDE "Extruir"
 	#define MSG_RETRACT "Retraer"
 	#define MSG_MOVE_AXIS "Mover ejes"
@@ -727,7 +727,7 @@
 	#define MSG_Z "z"
 	#define MSG_E "e"
 	#define MSG_VMIN "Vmin"
-	#define MSG_VTRAV_MIN "Vvacio min"
+	#define MSG_VTRAV_MIN "VTrav min"
 	#define MSG_AMAX "Amax"
 	#define MSG_A_RETRACT "A-retrac."
 	#define MSG_XSTEPS "X pasos/mm"
@@ -775,14 +775,14 @@
 	#define MSG_CONTROL_ARROW "Control"
 	#define MSG_RETRACT_ARROW "Retraer"
 	#define MSG_STEPPER_RELEASED "Desacoplada."
-	#define MSG_ZPROBE_OUT "sonda Z fuera"
-	#define MSG_POSITION_UNKNOWN "Reiniciar X/Y y Z"
-	#define MSG_ZPROBE_ZOFFSET "Offset Z"
+	#define MSG_ZPROBE_OUT "Z probe out. bed"
+	#define MSG_POSITION_UNKNOWN "Home X/Y before Z"
+	#define MSG_ZPROBE_ZOFFSET "Z Offset"
 	#define MSG_BABYSTEP_X "Babystep X"
 	#define MSG_BABYSTEP_Y "Babystep Y"
 	#define MSG_BABYSTEP_Z "Babystep Z"
 	#define MSG_ENDSTOP_ABORT "Endstop abort"
-	#define MSG_CONTRAST "Contraste"
+	#define MSG_CONTRAST "Contrast"
 
 #endif
 
diff -rupN ./Marlin/Marlin/Marlin_main.cpp ./Marlin_latest_MOD/Marlin/Marlin_main.cpp
--- ./Marlin/Marlin/Marlin_main.cpp	2014-11-29 01:24:30.380863505 +1300
+++ ./Marlin_latest_MOD/Marlin/Marlin_main.cpp	2014-11-29 01:05:43.247940356 +1300
@@ -1385,7 +1385,7 @@ void process_commands()
       st_synchronize();
       codenum += millis();  // keep track of when we started waiting
       previous_millis_cmd = millis();
-      while(millis() < codenum) {
+      while(millis()  < codenum ){
         manage_heater();
         manage_inactivity();
         lcd_update();
@@ -1413,6 +1413,7 @@ void process_commands()
       plan_bed_level_matrix.set_to_identity();  //Reset the plane ("erase" all leveling data)
 #endif //ENABLE_AUTO_BED_LEVELING
 
+
       saved_feedrate = feedrate;
       saved_feedmultiply = feedmultiply;
       feedmultiply = 100;
@@ -1862,39 +1863,20 @@ void process_commands()
     case 0: // M0 - Unconditional stop - Wait for user button press on LCD
     case 1: // M1 - Conditional stop - Wait for user button press on LCD
     {
-      char *src = strchr_pointer + 2;
-
+      LCD_MESSAGEPGM(MSG_USERWAIT);
       codenum = 0;
+      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
+      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
 
-      bool hasP = false, hasS = false;
-      if (code_seen('P')) {
-        codenum = code_value(); // milliseconds to wait
-        hasP = codenum > 0;
-      }
-      if (code_seen('S')) {
-        codenum = code_value() * 1000; // seconds to wait
-        hasS = codenum > 0;
-      }
-      if (!hasP && !hasS && *src != '\0') {
-        starpos = strchr(src, '*');
-        if (starpos != NULL) *(starpos) = '\0';
-        while (*src == ' ') ++src;
-        lcd_setstatus(src);
-      } else {
-        LCD_MESSAGEPGM(MSG_USERWAIT);
-      }
-
-      lcd_ignore_click();
       st_synchronize();
       previous_millis_cmd = millis();
       if (codenum > 0){
         codenum += millis();  // keep track of when we started waiting
-        while(millis() < codenum && !lcd_clicked()){
+        while(millis()  < codenum && !lcd_clicked()){
           manage_heater();
           manage_inactivity();
           lcd_update();
         }
-        lcd_ignore_click(false);
       }else{
         while(!lcd_clicked()){
           manage_heater();
@@ -1902,10 +1884,7 @@ void process_commands()
           lcd_update();
         }
       }
-      if (IS_SD_PRINTING)
-        LCD_MESSAGEPGM(MSG_RESUMING);
-      else
-        LCD_MESSAGEPGM(WELCOME_MSG);
+      LCD_MESSAGEPGM(MSG_RESUMING);
     }
     break;
 #endif
@@ -3951,6 +3930,29 @@ void clamp_to_software_endstops(float ta
 }
 
 #ifdef DELTA
+
+ float f = BASE_SIDE;
+
+float e = END_EFFECTOR_SIDE;
+
+float rf = DELTA_ARM_LENGTH;
+
+float re = DELTA_DIAGONAL_ROD;
+
+const float sin120 = DELTA_SIN120;
+
+const float cos120 = DELTA_COS120;
+
+float x0;
+
+float y0;
+
+float z0;
+
+
+// the function is called with like so at another point for the M665 gcode command:  recalc_delta_settings(delta_radius, delta_diagonal_rod);
+// for initial testing, this will be ignored
+
 void recalc_delta_settings(float radius, float diagonal_rod)
 {
 	 delta_tower1_x= -SIN_60*radius; // front left tower
@@ -3962,20 +3964,52 @@ void recalc_delta_settings(float radius,
 	 delta_diagonal_rod_2= sq(diagonal_rod);
 }
 
+int delta_calcAngleYZ(float x0, float y0, float zo, float& theta)
+
+{
+float y1 = -0.5 * 0.57735 * f; // f/2 * tg 30
+y0 -= 0.5 * 0.57735 * e; // shift center to edge
+// z = a + b*y
+float a = (x0*x0 + y0*y0 + z0*z0 +rf*rf - re*re - y1*y1)/(2*z0);
+float b = (y1-y0)/z0;
+// discriminant
+float d = -(a+b*y1)*(a+b*y1)+rf*(b*b*rf+rf);
+if (d < 0) return -1; // non-existing point
+float yj = (y1 - a*b - sqrt(d))/(b*b + 1); // choosing outer point
+float zj = a + b*yj;
+
+theta = 180.0*atan(-zj/(y1 - yj))/DELTA_PI + ((yj>y1)?180.0:0.0);
+
+return 0;
+
+}
+
 void calculate_delta(float cartesian[3])
 {
-  delta[X_AXIS] = sqrt(delta_diagonal_rod_2
-                       - sq(delta_tower1_x-cartesian[X_AXIS])
-                       - sq(delta_tower1_y-cartesian[Y_AXIS])
-                       ) + cartesian[Z_AXIS];
-  delta[Y_AXIS] = sqrt(delta_diagonal_rod_2
-                       - sq(delta_tower2_x-cartesian[X_AXIS])
-                       - sq(delta_tower2_y-cartesian[Y_AXIS])
-                       ) + cartesian[Z_AXIS];
-  delta[Z_AXIS] = sqrt(delta_diagonal_rod_2
-                       - sq(delta_tower3_x-cartesian[X_AXIS])
-                       - sq(delta_tower3_y-cartesian[Y_AXIS])
-                       ) + cartesian[Z_AXIS];
+
+// inverse kinematics: (x0, y0, z0) -> (theta1, theta2, theta3)
+// returned status: 0=OK, -1=non-existing position
+
+float theta1 = 0.0;
+float theta2 = 0.0;
+float theta3 = 0.0;
+
+x0 = cartesian[X_AXIS];
+y0 = cartesian[Y_AXIS];
+z0 = cartesian[Z_AXIS] - DELTA_HOME_POS;
+
+int status = delta_calcAngleYZ(x0, y0, z0, theta1);
+
+if (status == 0) status = delta_calcAngleYZ(x0*cos120 + y0*sin120, y0*cos120-x0*sin120, z0, theta2); // rotate coords to +120 deg
+
+if (status == 0) status = delta_calcAngleYZ(x0*cos120 - y0*sin120, y0*cos120+x0*sin120, z0, theta3); // rotate coords to -120 deg
+
+//not sure about the scaling here, needs work
+
+delta[X_AXIS] = -theta1*360/WHEEL_TEETH;
+delta[Y_AXIS] = -theta2*360/WHEEL_TEETH;
+delta[Z_AXIS] = -theta3*360/WHEEL_TEETH;
+
   /*
   SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);
   SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);
@@ -3985,6 +4019,7 @@ void calculate_delta(float cartesian[3])
   SERIAL_ECHOPGM(" y="); SERIAL_ECHO(delta[Y_AXIS]);
   SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(delta[Z_AXIS]);
   */
+
 }
 #endif
 
diff -rupN ./Marlin/Marlin/Marlin.pde ./Marlin_latest_MOD/Marlin/Marlin.pde
--- ./Marlin/Marlin/Marlin.pde	2014-11-29 01:24:30.376861505 +1300
+++ ./Marlin_latest_MOD/Marlin/Marlin.pde	1970-01-01 12:00:00.000000000 +1200
@@ -1,56 +0,0 @@
-/* -*- c++ -*- */
-
-/*
-    Reprap firmware based on Sprinter and grbl.
- Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
-
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
-
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/*
- This firmware is a mashup between Sprinter and grbl.
-  (https://github.com/kliment/Sprinter)
-  (https://github.com/simen/grbl/tree)
-
- It has preliminary support for Matthew Roberts advance algorithm
-    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
- */
-
-/* All the implementation is done in *.cpp files to get better compatibility with avr-gcc without the Arduino IDE */
-/* Use this file to help the Arduino IDE find which Arduino libraries are needed and to keep documentation on GCode */
-
-#include "Configuration.h"
-#include "pins.h"
-
-#ifdef ULTRA_LCD
-  #if defined(LCD_I2C_TYPE_PCF8575)
-    #include <Wire.h>
-    #include <LiquidCrystal_I2C.h>
-  #elif defined(LCD_I2C_TYPE_MCP23017) || defined(LCD_I2C_TYPE_MCP23008)
-    #include <Wire.h>
-    #include <LiquidTWI2.h>
-  #elif defined(DOGLCD)
-    #include <U8glib.h> // library for graphics LCD by Oli Kraus (https://code.google.com/p/u8glib/)
-  #else
-    #include <LiquidCrystal.h> // library for character LCD
-  #endif
-#endif
-
-#if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
-#include <SPI.h>
-#endif
-
-#if defined(DIGIPOT_I2C)
-  #include <Wire.h>
-#endif
diff -rupN ./Marlin/Marlin/ultralcd.cpp ./Marlin_latest_MOD/Marlin/ultralcd.cpp
--- ./Marlin/Marlin/ultralcd.cpp	2014-11-29 01:24:30.384865505 +1300
+++ ./Marlin_latest_MOD/Marlin/ultralcd.cpp	2014-11-17 02:57:31.000000000 +1300
@@ -162,8 +162,6 @@ bool lcd_oldcardstatus;
 menuFunc_t currentMenu = lcd_status_screen; /* function pointer to the currently active menu */
 uint32_t lcd_next_update_millis;
 uint8_t lcd_status_update_delay;
-bool ignore_click = false;
-bool wait_for_unclick;
 uint8_t lcdDrawUpdate = 2;                  /* Set to none-zero when the LCD needs to draw, decreased after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial) */
 
 //prevMenu and prevEncoderPosition are used to store the previous menu location when editing settings.
@@ -191,26 +189,7 @@ static void lcd_status_screen()
         lcd_status_update_delay = 10;   /* redraw the main screen every second. This is easier then trying keep track of all things that change on the screen */
     }
 #ifdef ULTIPANEL
-
-    bool current_click = LCD_CLICKED;
-
-    if (ignore_click) {
-        if (wait_for_unclick) {
-          if (!current_click) {
-              ignore_click = wait_for_unclick = false;
-          }
-          else {
-              current_click = false;
-          }
-        }
-        else if (current_click) {
-            lcd_quick_feedback();
-            wait_for_unclick = true;
-            current_click = false;
-        }
-    }
-
-    if (current_click)
+    if (LCD_CLICKED)
     {
         currentMenu = lcd_main_menu;
         encoderPosition = 0;
@@ -1336,12 +1315,6 @@ void lcd_update()
     }
 }
 
-void lcd_ignore_click(bool b)
-{
-    ignore_click = b;
-    wait_for_unclick = false;
-}
-
 void lcd_setstatus(const char* message)
 {
     if (lcd_status_message_level > 0)
diff -rupN ./Marlin/Marlin/ultralcd.h ./Marlin_latest_MOD/Marlin/ultralcd.h
--- ./Marlin/Marlin/ultralcd.h	2014-11-29 01:24:30.384865505 +1300
+++ ./Marlin_latest_MOD/Marlin/ultralcd.h	2014-11-17 02:57:31.000000000 +1300
@@ -48,8 +48,6 @@
   void lcd_buzz(long duration,uint16_t freq);
   bool lcd_clicked();
 
-  void lcd_ignore_click(bool b=true);
-
   #ifdef NEWPANEL
     #define EN_C (1<<BLEN_C)
     #define EN_B (1<<BLEN_B)
