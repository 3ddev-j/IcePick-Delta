diff -rupN ./Marlin/Marlin/Configuration_adv.h ./Marlin_latest_MOD/Marlin/Configuration_adv.h
--- ./Marlin/Marlin/Configuration_adv.h	2014-11-29 05:44:29.000000000 +1300
+++ ./Marlin_latest_MOD/Marlin/Configuration_adv.h	2014-12-09 16:44:28.962096889 +1300
@@ -11,30 +11,32 @@
 #define BED_CHECK_INTERVAL 5000 //ms between checks in bang-bang control
 
 //// Heating sanity check:
-// This waits for the watch period in milliseconds whenever an M104 or M109 increases the target temperature
-// If the temperature has not increased at the end of that period, the target temperature is set to zero.
+
+
+// This waits for the watchperiod in milliseconds whenever an M104 or M109 increases the target temperature
+// If the temperature has not increased at the end of that period, the target temperature is set to zero. 
 // It can be reset with another M104/M109. This check is also only triggered if the target temperature and the current temperature
 //  differ by at least 2x WATCH_TEMP_INCREASE
 //#define WATCH_TEMP_PERIOD 40000 //40 seconds
 //#define WATCH_TEMP_INCREASE 10  //Heat up at least 10 degree in 20 seconds
 
 #ifdef PIDTEMP
-  // this adds an experimental additional term to the heating power, proportional to the extrusion speed.
-  // if Kc is chosen well, the additional required power due to increased melting should be compensated.
-  #define PID_ADD_EXTRUSION_RATE
+  // this adds an experimental additional term to the heatingpower, proportional to the extrusion speed.
+  // if Kc is choosen well, the additional required power due to increased melting should be compensated.
+  #define PID_ADD_EXTRUSION_RATE  
   #ifdef PID_ADD_EXTRUSION_RATE
-    #define  DEFAULT_Kc (1) //heating power=Kc*(e_speed)
+    #define  DEFAULT_Kc (1) //heatingpower=Kc*(e_speed)
   #endif
 #endif
 
 
 //automatic temperature: The hot end target temperature is calculated by all the buffered lines of gcode.
 //The maximum buffered steps/sec of the extruder motor are called "se".
-//You enter the autotemp mode by a M109 S<mintemp> B<maxtemp> F<factor>
+//You enter the autotemp mode by a M109 S<mintemp> T<maxtemp> F<factor>
 // the target temperature is set to mintemp+factor*se[steps/sec] and limited by mintemp and maxtemp
 // you exit the value by any M109 without F*
 // Also, if the temperature is set to a value <mintemp, it is not changed by autotemp.
-// on an Ultimaker, some initial testing worked with M109 S215 B260 F1 in the start.gcode
+// on an ultimaker, some initial testing worked with M109 S215 B260 F1 in the start.gcode
 #define AUTOTEMP
 #ifdef AUTOTEMP
   #define AUTOTEMP_OLDWEIGHT 0.98
@@ -44,10 +46,10 @@
 //The M105 command return, besides traditional information, the ADC value read from temperature sensors.
 //#define SHOW_TEMP_ADC_VALUES
 
-//  extruder run-out prevention.
+//  extruder run-out prevention. 
 //if the machine is idle, and the temperature over MINTEMP, every couple of SECONDS some filament is extruded
-//#define EXTRUDER_RUNOUT_PREVENT
-#define EXTRUDER_RUNOUT_MINTEMP 190
+//#define EXTRUDER_RUNOUT_PREVENT  
+#define EXTRUDER_RUNOUT_MINTEMP 190  
 #define EXTRUDER_RUNOUT_SECONDS 30.
 #define EXTRUDER_RUNOUT_ESTEPS 14. //mm filament
 #define EXTRUDER_RUNOUT_SPEED 1500.  //extrusion speed
@@ -68,12 +70,12 @@
 // When first starting the main fan, run it at full speed for the
 // given number of milliseconds.  This gets the fan spinning reliably
 // before setting a PWM value. (Does not work with software PWM for fan on Sanguinololu)
-//#define FAN_KICKSTART_TIME 100
+#define FAN_KICKSTART_TIME 100
 
 // Extruder cooling fans
 // Configure fan pin outputs to automatically turn on/off when the associated
 // extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
+// Multiple extruders can be assigned to the same pin in which case 
 // the fan will turn on when any selected extruder is above the threshold.
 #define EXTRUDER_0_AUTO_FAN_PIN   -1
 #define EXTRUDER_1_AUTO_FAN_PIN   -1
@@ -103,14 +105,14 @@
     #else
       #define X_HOME_POS X_MIN_POS
     #endif //BED_CENTER_AT_0_0
-  #else
+  #else    
     #ifdef BED_CENTER_AT_0_0
       #define X_HOME_POS X_MAX_LENGTH * 0.5
     #else
       #define X_HOME_POS X_MAX_POS
     #endif //BED_CENTER_AT_0_0
   #endif //X_HOME_DIR == -1
-
+  
   //Y axis
   #if Y_HOME_DIR == -1
     #ifdef BED_CENTER_AT_0_0
@@ -118,18 +120,18 @@
     #else
       #define Y_HOME_POS Y_MIN_POS
     #endif //BED_CENTER_AT_0_0
-  #else
+  #else    
     #ifdef BED_CENTER_AT_0_0
       #define Y_HOME_POS Y_MAX_LENGTH * 0.5
     #else
       #define Y_HOME_POS Y_MAX_POS
     #endif //BED_CENTER_AT_0_0
   #endif //Y_HOME_DIR == -1
-
+  
   // Z axis
   #if Z_HOME_DIR == -1 //BED_CENTER_AT_0_0 not used
     #define Z_HOME_POS Z_MIN_POS
-  #else
+  #else    
     #define Z_HOME_POS Z_MAX_POS
   #endif //Z_HOME_DIR == -1
 #endif //End auto min/max positions
@@ -165,7 +167,7 @@
   #error "You cannot have dual drivers for both Y and Z"
 #endif
 
-// Enable this for dual x-carriage printers.
+// Enable this for dual x-carriage printers. 
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
 // allowing faster printing speeds.
@@ -175,10 +177,10 @@
 // Note: the first x-carriage is defined as the x-carriage which homes to the minimum endstop;
 // the second x-carriage always homes to the maximum endstop.
 #define X2_MIN_POS 80     // set minimum to ensure second x-carriage doesn't hit the parked first X-carriage
-#define X2_MAX_POS 353    // set maximum to the distance between toolheads when both heads are homed
+#define X2_MAX_POS 353    // set maximum to the distance between toolheads when both heads are homed 
 #define X2_HOME_DIR 1     // the second X-carriage always homes to the maximum endstop position
-#define X2_HOME_POS X2_MAX_POS // default home position is the maximum carriage position
-    // However: In this mode the EXTRUDER_OFFSET_X value for the second extruder provides a software
+#define X2_HOME_POS X2_MAX_POS // default home position is the maximum carriage position 
+    // However: In this mode the EXTRUDER_OFFSET_X value for the second extruder provides a software 
     // override for X2_HOME_POS. This also allow recalibration of the distance between the two endstops
     // without modifying the firmware (through the "M218 T1 X???" command).
     // Remember: you should set the second extruder x-offset to 0 in your slicer.
@@ -193,17 +195,17 @@
 //                           as long as it supports dual x-carriages. (M605 S0)
 //    Mode 1: Auto-park mode. The firmware will automatically park and unpark the x-carriages on tool changes so
 //                           that additional slicer support is not required. (M605 S1)
-//    Mode 2: Duplication mode. The firmware will transparently make the second x-carriage and extruder copy all
+//    Mode 2: Duplication mode. The firmware will transparently make the second x-carriage and extruder copy all  
 //                           actions of the first x-carriage. This allows the printer to print 2 arbitrary items at
 //                           once. (2nd extruder x offset and temp offset are set using: M605 S2 [Xnnn] [Rmmm])
 
-// This is the default power-up mode which can be later using M605.
-#define DEFAULT_DUAL_X_CARRIAGE_MODE 0
+// This is the default power-up mode which can be later using M605. 
+#define DEFAULT_DUAL_X_CARRIAGE_MODE 0 
 
 // As the x-carriages are independent we can now account for any relative Z offset
 #define EXTRUDER1_Z_OFFSET 0.0           // z offset relative to extruder 0
 
-// Default settings in "Auto-park Mode"
+// Default settings in "Auto-park Mode" 
 #define TOOLCHANGE_PARK_ZLIFT   0.2      // the distance to raise Z axis when parking an extruder
 #define TOOLCHANGE_UNPARK_ZLIFT 1        // the distance to raise Z axis when unparking an extruder
 
@@ -211,11 +213,12 @@
 #define DEFAULT_DUPLICATION_X_OFFSET 100
 
 #endif //DUAL_X_CARRIAGE
-
+    
 //homing hits the endstop, then retracts by this distance, before it tries to slowly bump again:
-#define X_HOME_RETRACT_MM 5
-#define Y_HOME_RETRACT_MM 5
-#define Z_HOME_RETRACT_MM 2
+#define X_HOME_RETRACT_MM 5 
+#define Y_HOME_RETRACT_MM 5 
+#define Z_HOME_RETRACT_MM 5 // deltas need the same for all three axis
+
 //#define QUICK_HOME  //if this is defined, if both x and y are to be homed, a diagonal move will be performed initially.
 
 #define AXIS_RELATIVE_MODES {false, false, false, false}
@@ -229,26 +232,22 @@
 #define INVERT_E_STEP_PIN false
 
 //default stepper release if idle
-#define DEFAULT_STEPPER_DEACTIVE_TIME 60
+#define DEFAULT_STEPPER_DEACTIVE_TIME 6000
 
 #define DEFAULT_MINIMUMFEEDRATE       0.0     // minimum feedrate
 #define DEFAULT_MINTRAVELFEEDRATE     0.0
 
 // Feedrates for manual moves along X, Y, Z, E from panel
 #ifdef ULTIPANEL
-#define MANUAL_FEEDRATE {50*60, 50*60, 4*60, 60}  // set the speeds for manual moves (mm/min)
-#endif
-
-//Comment to disable setting feedrate multiplier via encoder
-#ifdef ULTIPANEL
-    #define ULTIPANEL_FEEDMULTIPLY
+#define MANUAL_FEEDRATE {50*60, 50*60, 50*60, 60}  // set the speeds for manual moves (mm/min)
 #endif
 
 // minimum time in microseconds that a movement needs to take if the buffer is emptied.
 #define DEFAULT_MINSEGMENTTIME        20000
 
 // If defined the movements slow down when the look ahead buffer is only half full
-#define SLOWDOWN
+// (don't use SLOWDOWN with DELTA because DELTA generates hundreds of segments per second)
+//#define SLOWDOWN
 
 // Frequency limit
 // See nophead's blog for more info
@@ -290,12 +289,12 @@
 #define SD_FINISHED_STEPPERRELEASE true  //if sd support and the file is finished: disable steppers?
 #define SD_FINISHED_RELEASECOMMAND "M84 X Y Z E" // You might want to keep the z enabled so your bed stays in place.
 
-#define SDCARD_RATHERRECENTFIRST  //reverse file order of sd card menu display. Its sorted practically after the file system block order.
-// if a file is deleted, it frees a block. hence, the order is not purely chronological. To still have auto0.g accessible, there is again the option to do that.
+#define SDCARD_RATHERRECENTFIRST  //reverse file order of sd card menu display. Its sorted practically after the filesystem block order. 
+// if a file is deleted, it frees a block. hence, the order is not purely cronological. To still have auto0.g accessible, there is again the option to do that.
 // using:
 //#define MENU_ADDAUTOSTART
 
-// The hardware watchdog should reset the microcontroller disabling all outputs, in case the firmware gets stuck and doesn't do temperature regulation.
+// The hardware watchdog should reset the Microcontroller disabling all outputs, in case the firmware gets stuck and doesn't do temperature regulation.
 //#define USE_WATCHDOG
 
 #ifdef USE_WATCHDOG
@@ -309,14 +308,14 @@
 //#define ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
 
 // Babystepping enables the user to control the axis in tiny amounts, independently from the normal printing process
-// it can e.g. be used to change z-positions in the print startup phase in real-time
+// it can e.g. be used to change z-positions in the print startup phase in realtime
 // does not respect endstops!
 //#define BABYSTEPPING
 #ifdef BABYSTEPPING
   #define BABYSTEP_XY  //not only z, but also XY in the menu. more clutter, more functions
   #define BABYSTEP_INVERT_Z false  //true for inverse movements in Z
   #define BABYSTEP_Z_MULTIPLICATOR 2 //faster z movements
-
+  
   #ifdef COREXY
     #error BABYSTEPPING not implemented for COREXY yet.
   #endif
@@ -332,8 +331,8 @@
 //
 // advance (steps) = STEPS_PER_CUBIC_MM_E * EXTUDER_ADVANCE_K * cubic mm per second ^ 2
 //
-// Hooke's law says:		force = k * distance
-// Bernoulli's principle says:	v ^ 2 / 2 + g . h + pressure / density = constant
+// hooke's law says:		force = k * distance
+// bernoulli's priniciple says:	v ^ 2 / 2 + g . h + pressure / density = constant
 // so: v ^ 2 is proportional to number of steps we advance the extruder
 //#define ADVANCE
 
@@ -354,10 +353,10 @@
 const unsigned int dropsegments=5; //everything with less than this number of steps will be ignored as move and joined with the next movement
 
 // If you are using a RAMPS board or cheap E-bay purchased boards that do not detect when an SD card is inserted
-// You can get round this by connecting a push button or single throw switch to the pin defined as SDCARDCARDDETECT
+// You can get round this by connecting a push button or single throw switch to the pin defined as SDCARDCARDDETECT 
 // in the pins.h file.  When using a push button pulling the pin to ground this will need inverted.  This setting should
 // be commented out otherwise
-#define SDCARDDETECTINVERTED
+#define SDCARDDETECTINVERTED 
 
 #ifdef ULTIPANEL
  #undef SDCARDDETECTINVERTED
@@ -369,12 +368,12 @@ const unsigned int dropsegments=5; //eve
   #define POWER_SUPPLY 1
 #endif
 // 1 = ATX
-#if (POWER_SUPPLY == 1)
+#if (POWER_SUPPLY == 1) 
   #define PS_ON_AWAKE  LOW
   #define PS_ON_ASLEEP HIGH
 #endif
 // 2 = X-Box 360 203W
-#if (POWER_SUPPLY == 2)
+#if (POWER_SUPPLY == 2) 
   #define PS_ON_AWAKE  HIGH
   #define PS_ON_ASLEEP LOW
 #endif
@@ -386,8 +385,8 @@ const unsigned int dropsegments=5; //eve
 //=============================Buffers           ============================
 //===========================================================================
 
-// The number of linear motions that can be in the plan at any give time.
-// THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
+// The number of linear motions that can be in the plan at any give time.  
+// THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ringbuffering.
 #if defined SDSUPPORT
   #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
@@ -395,15 +394,15 @@ const unsigned int dropsegments=5; //eve
 #endif
 
 
-//The ASCII buffer for receiving from the serial:
+//The ASCII buffer for recieving from the serial:
 #define MAX_CMD_SIZE 96
 #define BUFSIZE 4
 
 
-// Firmware based and LCD controlled retract
-// M207 and M208 can be used to define parameters for the retraction.
+// Firmware based and LCD controled retract
+// M207 and M208 can be used to define parameters for the retraction. 
 // The retraction can be called by the slicer using G10 and G11
-// until then, intended retractions can be detected by moves that only extrude and the direction.
+// until then, intended retractions can be detected by moves that only extrude and the direction. 
 // the moves are than replaced by the firmware controlled ones.
 
 // #define FWRETRACT  //ONLY PARTIALLY TESTED
@@ -433,9 +432,9 @@ const unsigned int dropsegments=5; //eve
 #ifdef FILAMENTCHANGEENABLE
   #ifdef EXTRUDER_RUNOUT_PREVENT
     #error EXTRUDER_RUNOUT_PREVENT currently incompatible with FILAMENTCHANGE
-  #endif
+  #endif 
 #endif
-
+ 
 //===========================================================================
 //=============================  Define Defines  ============================
 //===========================================================================
diff -rupN ./Marlin/Marlin/Configuration.h ./Marlin_latest_MOD/Marlin/Configuration.h
--- ./Marlin/Marlin/Configuration.h	2014-11-29 05:44:29.000000000 +1300
+++ ./Marlin_latest_MOD/Marlin/Configuration.h	2014-12-09 16:35:53.034075500 +1300
@@ -12,13 +12,6 @@
 // example_configurations/delta directory.
 //
 
-//===========================================================================
-//============================= SCARA Printer ===============================
-//===========================================================================
-// For a Delta printer replace the configuration files with the files in the
-// example_configurations/SCARA directory.
-//
-
 // User-specified version info of this build to display in [Pronterface, etc] terminal window during
 // startup. Implementation of an idea by Prof Braino to inform user that any changes made to this
 // build by the user have been successfully uploaded into firmware.
@@ -31,7 +24,7 @@
 #define SERIAL_PORT 0
 
 // This determines the communication speed of the printer
-#define BAUDRATE 250000
+#define BAUDRATE 115200
 
 // This enables the serial port associated to the Bluetooth interface
 //#define BTENABLED              // Enable BT interface on AT90USB devices
@@ -81,9 +74,9 @@
 // 88 = 5DPrint D8 Driver Board
 // 999 = Leapfrog
 
-#ifndef MOTHERBOARD
-#define MOTHERBOARD 7
-#endif
+//#ifndef MOTHERBOARD
+#define MOTHERBOARD 33
+//#endif
 
 // Define this to set a custom name for your generic Mendel,
 // #define CUSTOM_MENDEL_NAME "This Mendel"
@@ -105,6 +98,76 @@
 // #define PS_DEFAULT_OFF
 
 //===========================================================================
+//============================== Delta Settings =============================
+//===========================================================================
+// Enable DELTA kinematics and most of the default configuration for Deltas
+#define DELTA
+
+// NOTE NB all values for DELTA_* values MUST be floating point, so always have a decimal point in them
+
+// Make delta curves from many straight lines (linear interpolation).
+// This is a trade-off between visible corners (not enough segments)
+// and processor overload (too many expensive sqrt calls).
+#define DELTA_SEGMENTS_PER_SECOND 40
+
+// Horizontal offset of the pulley axle centres from the mounting plate centre
+#define BASE_RADIUS 135.0
+
+// Horizontal radius of the end effector centre to the tangentline where the joints are
+// making this value large will make prints scale larger in xy direction as z gets higher  
+#define END_EFFECTOR_RADIUS 20.0 // 20.0mm for kossel end effector
+
+// Center-to-center distance of the holes in the diagonal push rods.
+#define DELTA_DIAGONAL_ROD 302.0 // this has to EXACT. 2mm off and the hotend will far be too high or low in the middle of the printbed relative to edges
+
+// actuator arm length (aka upper arm)
+// if your hotend is close/too far from the bed near the edges, check this is correct
+#define DELTA_ARM_LENGTH 160.0 //188.0
+
+// distance from home position to bed. If this value isn't linear for you, it means one or more of your other values is not accurate/correct
+#define Z_HOME_HEIGTH 262.0
+
+// vertical distance from vertical midpoint of the end effector to mounting plate 
+// this controls whether objects get narrower or wider as it gets taller
+// towards the edges of the print bed this will become more apparent
+// will also affect how far the machine thinks it can reach
+// reduce this value to get wider as it gets taller
+#define END_EFFECTOR_TO_MOUNTPLATE 199.0 // actual number -> 201.5
+
+// handy hint: for tuning the above value, first measure what the actual value is and enter it.
+// next test if is correct: move the end effector to z0 and as near to the edge of the print bed as you can get it.
+// set a square object against the hotend and move the hotend to Z50 and see if there is a gap, if there is, increase the value and try again, if not read on
+// move the hotend back down to z0 and observe if there is a gap between the object and the hotend, if there is, decrease the value
+
+
+// vertical distance from the pulley axles to the mounting plate
+#define PULLEY_MOUNT_HEIGHT 63.5
+
+
+// trigonometric constants
+#define DELTA_SQRT3 1.732050807
+#define DELTA_PI 3.141592653; // PI
+#define DELTA_SIN120 DELTA_SQRT3/2.0
+#define DELTA_COS120 -0.5;
+#define DELTA_TAN60 DELTA_SQRT3;
+#define DELTA_SIN30 0.5;
+#define DELTA_TAN30 1/DELTA_SQRT3;
+
+// base side length (length of the side of the equilateral triangle)
+#define BASE_SIDE BASE_RADIUS*2*sqrt(3)
+
+// end effector side length (length of the side of the equilateral triangle)
+#define END_EFFECTOR_SIDE END_EFFECTOR_RADIUS*2*sqrt(3)
+
+// calculate the vertical distance from vertical midpoint of the end effector to the pulley axle height
+#define DELTA_HOME_POS MANUAL_Z_HOME_POS - (END_EFFECTOR_TO_MOUNTPLATE - PULLEY_MOUNT_HEIGHT)
+
+// Effective horizontal distance bridged by diagonal push rods.
+// Irrelevant for non linear deltas, but the rest of the code still expect this value to exist
+#define DELTA_RADIUS 20 //(DELTA_SMOOTH_ROD_OFFSET-DELTA_EFFECTOR_OFFSET-DELTA_CARRIAGE_OFFSET)
+
+
+//===========================================================================
 //=============================Thermal Settings  ============================
 //===========================================================================
 //
@@ -136,16 +199,17 @@
 // 51 is 100k thermistor - EPCOS (1k pullup)
 // 52 is 200k thermistor - ATC Semitec 204GT-2 (1k pullup)
 // 55 is 100k thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (1k pullup)
+// 56 is 100k thermistor - 100K NTC thermistor from robotdigg.com using table provided
 //
 // 1047 is Pt1000 with 4k7 pullup
 // 1010 is Pt1000 with 1k pullup (non standard)
 // 147 is Pt100 with 4k7 pullup
 // 110 is Pt100 with 1k pullup (non standard)
 
-#define TEMP_SENSOR_0 -1
-#define TEMP_SENSOR_1 -1
+#define TEMP_SENSOR_0 1
+#define TEMP_SENSOR_1 0
 #define TEMP_SENSOR_2 0
-#define TEMP_SENSOR_BED 0
+#define TEMP_SENSOR_BED 1
 
 // This makes temp sensor 1 a redundant sensor for sensor 0. If the temperatures difference between these sensors is to high the print will be aborted.
 //#define TEMP_SENSOR_1_AS_REDUNDANT
@@ -159,7 +223,7 @@
 // The minimal temperature defines the temperature below which the heater will not be enabled It is used
 // to check that the wiring to the thermistor is not broken.
 // Otherwise this would lead to the heater being powered on all the time.
-#define HEATER_0_MINTEMP 5
+#define HEATER_0_MINTEMP 2
 #define HEATER_1_MINTEMP 5
 #define HEATER_2_MINTEMP 5
 #define BED_MINTEMP 5
@@ -167,9 +231,9 @@
 // When temperature exceeds max temp, your heater will be switched off.
 // This feature exists to protect your hotend from overheating accidentally, but *NOT* from thermistor short/failure!
 // You should use MINTEMP for thermistor short/failure protection.
-#define HEATER_0_MAXTEMP 275
-#define HEATER_1_MAXTEMP 275
-#define HEATER_2_MAXTEMP 275
+#define HEATER_0_MAXTEMP 245
+#define HEATER_1_MAXTEMP 245
+#define HEATER_2_MAXTEMP 245
 #define BED_MAXTEMP 150
 
 // If your bed has low resistance e.g. .6 ohm and throws the fuse you can duty cycle it to reduce the
@@ -184,8 +248,8 @@
 // PID settings:
 // Comment the following line to disable PID and enable bang-bang.
 #define PIDTEMP
-#define BANG_MAX 255 // limits current to nozzle while in bang-bang mode; 255=full current
-#define PID_MAX 255 // limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 255=full current
+#define BANG_MAX 170 // limits current to nozzle while in bang-bang mode; 255=full current
+#define PID_MAX 170 // limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 255=full current
 #ifdef PIDTEMP
   //#define PID_DEBUG // Sends debug data to the serial port.
   //#define PID_OPENLOOP 1 // Puts PID in open loop. M104/M140 sets the output power from 0 to PID_MAX
@@ -197,19 +261,16 @@
 
 // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
 // Ultimaker
-    #define  DEFAULT_Kp 22.2
-    #define  DEFAULT_Ki 1.08
-    #define  DEFAULT_Kd 114
-
-// MakerGear
-//    #define  DEFAULT_Kp 7.0
-//    #define  DEFAULT_Ki 0.1
-//    #define  DEFAULT_Kd 12
-
-// Mendel Parts V9 on 12V
-//    #define  DEFAULT_Kp 63.0
-//    #define  DEFAULT_Ki 2.25
-//    #define  DEFAULT_Kd 440
+    //#define  DEFAULT_Kp 11.58
+    //#define  DEFAULT_Ki 1.24
+    //#define  DEFAULT_Kd 27.03
+    
+// My J-head hotend
+    #define  DEFAULT_Kp 12.47
+    #define  DEFAULT_Ki 1.44
+    #define  DEFAULT_Kd 27.08
+
+
 #endif // PIDTEMP
 
 // Bed Temperature Control
@@ -232,21 +293,14 @@
 // so you shouldn't use it unless you are OK with PWM on your bed.  (see the comment on enabling PIDTEMPBED)
 #define MAX_BED_POWER 255 // limits duty cycle to bed; 255=full current
 
-#ifdef PIDTEMPBED
-//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
-//from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
-    #define  DEFAULT_bedKp 10.00
-    #define  DEFAULT_bedKi .023
-    #define  DEFAULT_bedKd 305.4
-
-//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
-//from pidautotune
-//    #define  DEFAULT_bedKp 97.1
-//    #define  DEFAULT_bedKi 1.41
-//    #define  DEFAULT_bedKd 1675.16
 
-// FIND YOUR OWN: "M303 E-1 C8 S90" to run autotune on the bed at 90 degreesC for 8 cycles.
-#endif // PIDTEMPBED
+
+#ifdef PIDTEMPBED
+// pid bed settings
+    #define  DEFAULT_bedKp 57.72
+    #define  DEFAULT_bedKi 1.42
+    #define  DEFAULT_bedKd 587.55
+#endif
 
 
 
@@ -256,7 +310,7 @@
 //if PREVENT_DANGEROUS_EXTRUDE is on, you can still disable (uncomment) very long bits of extrusion separately.
 #define PREVENT_LENGTHY_EXTRUDE
 
-#define EXTRUDE_MINTEMP 170
+#define EXTRUDE_MINTEMP 150
 #define EXTRUDE_MAXLENGTH (X_MAX_LENGTH+Y_MAX_LENGTH) //prevent extrusion of very large distances.
 
 /*================== Thermal Runaway Protection ==============================
@@ -292,7 +346,7 @@ your extruder heater takes 2 minutes to
 // uncomment the 2 defines below:
 
 // Parameters for the bed heater
-//#define THERMAL_RUNAWAY_PROTECTION_BED_PERIOD 20 //in seconds
+//#define THERMAL_RUNAWAY_PROTECTION_BED_PERIOD 300000 //in seconds
 //#define THERMAL_RUNAWAY_PROTECTION_BED_HYSTERESIS 2 // in degree Celsius
 //===========================================================================
 
@@ -304,38 +358,41 @@ your extruder heater takes 2 minutes to
 // Uncomment the following line to enable CoreXY kinematics
 // #define COREXY
 
+// The software assumes that the upper arms are perfectly horizontal when in the homed position
+// THIS IS CRITICAL if this is not the case, your objects will either be to short or too tall
+
 // coarse Endstop Settings
 #define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors
 
 #ifndef ENDSTOPPULLUPS
   // fine endstop settings: Individual pullups. will be ignored if ENDSTOPPULLUPS is defined
-  // #define ENDSTOPPULLUP_XMAX
-  // #define ENDSTOPPULLUP_YMAX
-  // #define ENDSTOPPULLUP_ZMAX
+    #define ENDSTOPPULLUP_XMAX
+    #define ENDSTOPPULLUP_YMAX
+    #define ENDSTOPPULLUP_ZMAX
   // #define ENDSTOPPULLUP_XMIN
   // #define ENDSTOPPULLUP_YMIN
-  // #define ENDSTOPPULLUP_ZMIN
+    #define ENDSTOPPULLUP_ZMIN
 #endif
 
 #ifdef ENDSTOPPULLUPS
   #define ENDSTOPPULLUP_XMAX
   #define ENDSTOPPULLUP_YMAX
   #define ENDSTOPPULLUP_ZMAX
-  #define ENDSTOPPULLUP_XMIN
-  #define ENDSTOPPULLUP_YMIN
+  //#define ENDSTOPPULLUP_XMIN
+  //#define ENDSTOPPULLUP_YMIN
   #define ENDSTOPPULLUP_ZMIN
 #endif
 
 // The pullups are needed if you directly connect a mechanical endswitch between the signal and ground pins.
-const bool X_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool Y_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool Z_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool X_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool Y_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool X_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool Y_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool Z_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool X_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool Y_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool Z_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
 //#define DISABLE_MAX_ENDSTOPS
+// Deltas never have min endstops
 //#define DISABLE_MIN_ENDSTOPS
-
 // Disable max endstops for compatibility with endstop checking routine
 #if defined(COREXY) && !defined(DISABLE_MAX_ENDSTOPS)
   #define DISABLE_MAX_ENDSTOPS
@@ -354,28 +411,30 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
 #define DISABLE_E false // For all extruders
 #define DISABLE_INACTIVE_EXTRUDER true //disable only inactive extruders and keep active extruder enabled
 
-#define INVERT_X_DIR true    // for Mendel set to false, for Orca set to true
-#define INVERT_Y_DIR false    // for Mendel set to true, for Orca set to false
-#define INVERT_Z_DIR true     // for Mendel set to false, for Orca set to true
-#define INVERT_E0_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false
+#define INVERT_X_DIR false // DELTA does not invert
+#define INVERT_Y_DIR false
+#define INVERT_Z_DIR false
+
+#define INVERT_E0_DIR true   // for direct drive extruder v9 set to true, for geared extruder set to false
 #define INVERT_E1_DIR false    // for direct drive extruder v9 set to true, for geared extruder set to false
 #define INVERT_E2_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false
 
 // ENDSTOP SETTINGS:
 // Sets direction of endstops when homing; 1=MAX, -1=MIN
-#define X_HOME_DIR -1
-#define Y_HOME_DIR -1
-#define Z_HOME_DIR -1
+// deltas always home to max
+#define X_HOME_DIR 1
+#define Y_HOME_DIR 1
+#define Z_HOME_DIR 1
 
 #define min_software_endstops true // If true, axis won't move to coordinates less than HOME_POS.
 #define max_software_endstops true  // If true, axis won't move to coordinates greater than the defined lengths below.
 
 // Travel limits after homing
-#define X_MAX_POS 205
-#define X_MIN_POS 0
-#define Y_MAX_POS 205
-#define Y_MIN_POS 0
-#define Z_MAX_POS 200
+#define X_MAX_POS 101
+#define X_MIN_POS -101
+#define Y_MAX_POS 101
+#define Y_MIN_POS -101
+#define Z_MAX_POS MANUAL_Z_HOME_POS
 #define Z_MIN_POS 0
 
 #define X_MAX_LENGTH (X_MAX_POS - X_MIN_POS)
@@ -384,7 +443,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
 //============================= Bed Auto Leveling ===========================
 
 //#define ENABLE_AUTO_BED_LEVELING // Delete the comment to enable (remove // at the start of the line)
-#define Z_PROBE_REPEATABILITY_TEST  // If not commented out, Z-Probe Repeatability test will be included if Auto Bed Leveling is Enabled.
+//#define Z_PROBE_REPEATABILITY_TEST  // If not commented out, Z-Probe Repeatability test will be included if Auto Bed Leveling is Enabled.
 
 #ifdef ENABLE_AUTO_BED_LEVELING
 
@@ -400,7 +459,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
 //    Probe 3 arbitrary points on the bed (that aren't colinear)
 //    You must specify the X & Y coordinates of all 3 points
 
-  #define AUTO_BED_LEVELING_GRID
+  //#define AUTO_BED_LEVELING_GRID
   // with AUTO_BED_LEVELING_GRID, the bed is sampled in a
   // AUTO_BED_LEVELING_GRID_POINTSxAUTO_BED_LEVELING_GRID_POINTS grid
   // and least squares solution is calculated
@@ -409,13 +468,13 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
 
     // set the rectangle in which to probe
     #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define BACK_PROBE_BED_POSITION 180
+    #define RIGHT_PROBE_BED_POSITION 90
+    #define BACK_PROBE_BED_POSITION 90
     #define FRONT_PROBE_BED_POSITION 20
 
      // set the number of grid points per dimension
      // I wouldn't see a reason to go above 3 (=9 probing points on the bed)
-    #define AUTO_BED_LEVELING_GRID_POINTS 2
+    #define AUTO_BED_LEVELING_GRID_POINTS 3
 
 
   #else  // not AUTO_BED_LEVELING_GRID
@@ -423,10 +482,10 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
     // is used to esimate the plane of the print bed
 
       #define ABL_PROBE_PT_1_X 15
-      #define ABL_PROBE_PT_1_Y 180
+      #define ABL_PROBE_PT_1_Y 90
       #define ABL_PROBE_PT_2_X 15
       #define ABL_PROBE_PT_2_Y 20
-      #define ABL_PROBE_PT_3_X 170
+      #define ABL_PROBE_PT_3_X 90
       #define ABL_PROBE_PT_3_Y 20
 
   #endif // AUTO_BED_LEVELING_GRID
@@ -436,14 +495,13 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
   #define X_PROBE_OFFSET_FROM_EXTRUDER -25
   #define Y_PROBE_OFFSET_FROM_EXTRUDER -29
   #define Z_PROBE_OFFSET_FROM_EXTRUDER -12.35
-
-  #define Z_RAISE_BEFORE_HOMING 4       // (in mm) Raise Z before homing (G28) for Probe Clearance.
+  #define Z_RAISE_BEFORE_HOMING 20      // (in mm) Raise Z before homing (G28) for Probe Clearance.
                                         // Be sure you have this distance over your Z_MAX_POS in case
 
-  #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min
+  #define XY_TRAVEL_SPEED 3000         // X and Y axis travel speed between probes, in mm/min
 
-  #define Z_RAISE_BEFORE_PROBING 15    //How much the extruder will be raised before traveling to the first probing point.
-  #define Z_RAISE_BETWEEN_PROBINGS 5  //How much the extruder will be raised when traveling from between next probing points
+  #define Z_RAISE_BEFORE_PROBING 30    //How much the extruder will be raised before traveling to the first probing point.
+  #define Z_RAISE_BETWEEN_PROBINGS 40  //How much the extruder will be raised when traveling from between next probing points
 
   //#define Z_PROBE_SLED // turn on if you have a z-probe mounted on a sled like those designed by Charles Bell
   //#define SLED_DOCKING_OFFSET 5 // the extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
@@ -458,7 +516,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
 //If you have enabled the Bed Auto Leveling and are using the same Z Probe for Z Homing,
 //it is highly recommended you let this Z_SAFE_HOMING enabled!!!
 
-  #define Z_SAFE_HOMING   // This feature is meant to avoid Z homing with probe outside the bed area.
+  //#define Z_SAFE_HOMING   // This feature is meant to avoid Z homing with probe outside the bed area.
                           // When defined, it will:
                           // - Allow Z homing only after X and Y homing AND stepper drivers still enabled
                           // - If stepper drivers timeout, it will need X and Y homing again before Z homing
@@ -476,27 +534,47 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
 
 
 // The position of the homing switches
-//#define MANUAL_HOME_POSITIONS  // If defined, MANUAL_*_HOME_POS below will be used
-//#define BED_CENTER_AT_0_0  // If defined, the center of the bed is at (X=0, Y=0)
+#define MANUAL_HOME_POSITIONS  // If defined, MANUAL_*_HOME_POS below will be used
+#define BED_CENTER_AT_0_0  // If defined, the center of the bed is at (X=0, Y=0)
 
 //Manual homing switch locations:
+
+#define MANUAL_HOME_POSITIONS  // MANUAL_*_HOME_POS below will be used
 // For deltabots this means top and center of the Cartesian print volume.
 #define MANUAL_X_HOME_POS 0
 #define MANUAL_Y_HOME_POS 0
-#define MANUAL_Z_HOME_POS 0
-//#define MANUAL_Z_HOME_POS 402 // For delta: Distance between nozzle and print surface after homing.
+#define MANUAL_Z_HOME_POS Z_HOME_HEIGTH // For delta: Distance between nozzle and print surface after homing.
 
 //// MOVEMENT SETTINGS
 #define NUM_AXIS 4 // The axis order in all axis related arrays is X, Y, Z, E
-#define HOMING_FEEDRATE {50*60, 50*60, 4*60, 0}  // set the homing speeds (mm/min)
+
+// delta homing speeds must be the same on xyz
+#define HOMING_FEEDRATE {50*60, 50*60, 50*60, 0}  // set the homing speeds (mm/min)
+
+// steps per rotation on xyz steppers
+#define StepsPerRotation 3200.0
+
+// number of teeth on stepper motor pulley
+#define TopPulleyTeeth 16.0
+
+// number of teeth on bottom pulley, 225 for icepick delta
+#define BottomPulleyTeeth 225.0
+
+// steps per rotation of bottom pulley
+#define StepBottomPulley StepsPerRotation*TopPulleyTeeth/BottomPulleyTeeth
+
+// needs work, see marlin_main.cpp line 4009
+// final scaling on all axi at end of equations is XXX *360/WHEEL_TEETH;
+
 
 // default settings
+// delta speeds must be the same on xyz
+#define DEFAULT_AXIS_STEPS_PER_UNIT   {97.087*StepBottomPulley/180.0, 97.108*StepBottomPulley/180.0, 97.517*StepBottomPulley/180.0, 610.2}  // default steps per unit. Only adjust extruder steps, for other steps calibrate adjust WHEEL_TEETH above
 
-#define DEFAULT_AXIS_STEPS_PER_UNIT   {78.7402,78.7402,200.0*8/3,760*1.1}  // default steps per unit for Ultimaker
-#define DEFAULT_MAX_FEEDRATE          {500, 500, 5, 25}    // (mm/sec)
-#define DEFAULT_MAX_ACCELERATION      {9000,9000,100,10000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for Skeinforge 40+, for older versions raise them a lot.
+#define DEFAULT_MAX_FEEDRATE          {50, 50, 50, 40}    // (mm/sec)
+#define DEFAULT_MAX_ACCELERATION      {400,400,400,3000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for skeinforge 40+, for older versions raise them a lot.
 
-#define DEFAULT_ACCELERATION          3000    // X, Y, Z and E max acceleration in mm/s^2 for printing moves
+#define DEFAULT_ACCELERATION          400    // X, Y, Z and E max acceleration in mm/s^2 for printing moves
 #define DEFAULT_RETRACT_ACCELERATION  3000   // X, Y, Z and E max acceleration in mm/s^2 for retracts
 
 // Offset of the extruders (uncomment if using more than one and relying on firmware to position when changing).
@@ -507,8 +585,8 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
 
 // The speed change that does not require acceleration (i.e. the software might assume it can be done instantaneously)
 #define DEFAULT_XYJERK                20.0    // (mm/sec)
-#define DEFAULT_ZJERK                 0.4     // (mm/sec)
-#define DEFAULT_EJERK                 5.0    // (mm/sec)
+#define DEFAULT_ZJERK       DEFAULT_XYJERK    // same as xY jerk for delta
+#define DEFAULT_EJERK                  5.0    // (mm/sec)
 
 //===========================================================================
 //=============================Additional Features===========================
@@ -517,7 +595,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
 // Custom M code points
 #define CUSTOM_M_CODES
 #ifdef CUSTOM_M_CODES
-  #define CUSTOM_M_CODE_SET_Z_PROBE_OFFSET 851
+  #define CUSTOM_M_CODE_SET_Z_PROBE_OFFSET 851 // seems large, is default with marlin
   #define Z_PROBE_OFFSET_RANGE_MIN -15
   #define Z_PROBE_OFFSET_RANGE_MAX -5
 #endif
@@ -777,9 +855,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = tru
  * 301 - Rambo  - uses Analog input 3
  * Note may require analog pins to be defined for different motherboards
  **********************************************************************/
-// Uncomment below to enable
-//#define FILAMENT_SENSOR
-
+#define FILAMENT_SENSOR
 #define FILAMENT_SENSOR_EXTRUDER_NUM	0  //The number of the extruder that has the filament sensor (0,1,2)
 #define MEASUREMENT_DELAY_CM			14  //measurement delay in cm.  This is the distance from filament sensor to middle of barrel
 
diff -rupN ./Marlin/Marlin/language.h ./Marlin_latest_MOD/Marlin/language.h
--- ./Marlin/Marlin/language.h	2014-11-29 05:44:29.000000000 +1300
+++ ./Marlin_latest_MOD/Marlin/language.h	2014-11-17 02:57:31.000000000 +1300
@@ -665,7 +665,7 @@
 	#define MSG_AUTOSTART " Autostart"
 	#define MSG_DISABLE_STEPPERS "Apagar motores"
 	#define MSG_AUTO_HOME "Llevar al origen"
-	#define MSG_SET_HOME_OFFSETS "Ajustar offsets"
+	#define MSG_SET_HOME_OFFSETS "Set home offsets"
 	#define MSG_SET_ORIGIN "Establecer cero"
 	#define MSG_PREHEAT_PLA "Precalentar PLA"
 	#define MSG_PREHEAT_PLA0 "Precalentar PLA 1"
@@ -682,8 +682,8 @@
 	#define MSG_PREHEAT_ABS_BEDONLY "Precal. ABS Base"
 	#define MSG_PREHEAT_ABS_SETTINGS "Ajustar temp. ABS"
 	#define MSG_COOLDOWN "Enfriar"
-	#define MSG_SWITCH_PS_ON "Encender"
-	#define MSG_SWITCH_PS_OFF "Apagar"
+	#define MSG_SWITCH_PS_ON "Switch Power On"
+	#define MSG_SWITCH_PS_OFF "Switch Power Off"
 	#define MSG_EXTRUDE "Extruir"
 	#define MSG_RETRACT "Retraer"
 	#define MSG_MOVE_AXIS "Mover ejes"
@@ -727,7 +727,7 @@
 	#define MSG_Z "z"
 	#define MSG_E "e"
 	#define MSG_VMIN "Vmin"
-	#define MSG_VTRAV_MIN "Vvacio min"
+	#define MSG_VTRAV_MIN "VTrav min"
 	#define MSG_AMAX "Amax"
 	#define MSG_A_RETRACT "A-retrac."
 	#define MSG_XSTEPS "X pasos/mm"
@@ -775,14 +775,14 @@
 	#define MSG_CONTROL_ARROW "Control"
 	#define MSG_RETRACT_ARROW "Retraer"
 	#define MSG_STEPPER_RELEASED "Desacoplada."
-	#define MSG_ZPROBE_OUT "sonda Z fuera"
-	#define MSG_POSITION_UNKNOWN "Reiniciar X/Y y Z"
-	#define MSG_ZPROBE_ZOFFSET "Offset Z"
+	#define MSG_ZPROBE_OUT "Z probe out. bed"
+	#define MSG_POSITION_UNKNOWN "Home X/Y before Z"
+	#define MSG_ZPROBE_ZOFFSET "Z Offset"
 	#define MSG_BABYSTEP_X "Babystep X"
 	#define MSG_BABYSTEP_Y "Babystep Y"
 	#define MSG_BABYSTEP_Z "Babystep Z"
 	#define MSG_ENDSTOP_ABORT "Endstop abort"
-	#define MSG_CONTRAST "Contraste"
+	#define MSG_CONTRAST "Contrast"
 
 #endif
 
diff -rupN ./Marlin/Marlin/Marlin_main.cpp ./Marlin_latest_MOD/Marlin/Marlin_main.cpp
--- ./Marlin/Marlin/Marlin_main.cpp	2014-11-29 05:44:29.000000000 +1300
+++ ./Marlin_latest_MOD/Marlin/Marlin_main.cpp	2014-12-08 16:21:17.375188751 +1300
@@ -1385,7 +1385,7 @@ void process_commands()
       st_synchronize();
       codenum += millis();  // keep track of when we started waiting
       previous_millis_cmd = millis();
-      while(millis() < codenum) {
+      while(millis()  < codenum ){
         manage_heater();
         manage_inactivity();
         lcd_update();
@@ -1413,6 +1413,7 @@ void process_commands()
       plan_bed_level_matrix.set_to_identity();  //Reset the plane ("erase" all leveling data)
 #endif //ENABLE_AUTO_BED_LEVELING
 
+
       saved_feedrate = feedrate;
       saved_feedmultiply = feedmultiply;
       feedmultiply = 100;
@@ -1862,39 +1863,20 @@ void process_commands()
     case 0: // M0 - Unconditional stop - Wait for user button press on LCD
     case 1: // M1 - Conditional stop - Wait for user button press on LCD
     {
-      char *src = strchr_pointer + 2;
-
+      LCD_MESSAGEPGM(MSG_USERWAIT);
       codenum = 0;
+      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
+      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
 
-      bool hasP = false, hasS = false;
-      if (code_seen('P')) {
-        codenum = code_value(); // milliseconds to wait
-        hasP = codenum > 0;
-      }
-      if (code_seen('S')) {
-        codenum = code_value() * 1000; // seconds to wait
-        hasS = codenum > 0;
-      }
-      starpos = strchr(src, '*');
-      if (starpos != NULL) *(starpos) = '\0';
-      while (*src == ' ') ++src;
-      if (!hasP && !hasS && *src != '\0') {
-        lcd_setstatus(src);
-      } else {
-        LCD_MESSAGEPGM(MSG_USERWAIT);
-      }
-
-      lcd_ignore_click();
       st_synchronize();
       previous_millis_cmd = millis();
       if (codenum > 0){
         codenum += millis();  // keep track of when we started waiting
-        while(millis() < codenum && !lcd_clicked()){
+        while(millis()  < codenum && !lcd_clicked()){
           manage_heater();
           manage_inactivity();
           lcd_update();
         }
-        lcd_ignore_click(false);
       }else{
         while(!lcd_clicked()){
           manage_heater();
@@ -1902,10 +1884,7 @@ void process_commands()
           lcd_update();
         }
       }
-      if (IS_SD_PRINTING)
-        LCD_MESSAGEPGM(MSG_RESUMING);
-      else
-        LCD_MESSAGEPGM(WELCOME_MSG);
+      LCD_MESSAGEPGM(MSG_RESUMING);
     }
     break;
 #endif
@@ -3951,6 +3930,29 @@ void clamp_to_software_endstops(float ta
 }
 
 #ifdef DELTA
+
+ float f = BASE_SIDE;
+
+float e = END_EFFECTOR_SIDE;
+
+float rf = DELTA_ARM_LENGTH;
+
+float re = DELTA_DIAGONAL_ROD;
+
+const float sin120 = DELTA_SIN120;
+
+const float cos120 = DELTA_COS120;
+
+float x0;
+
+float y0;
+
+float z0;
+
+
+// the function is called with like so at another point for the M665 gcode command:  recalc_delta_settings(delta_radius, delta_diagonal_rod);
+// for initial testing, this will be ignored
+
 void recalc_delta_settings(float radius, float diagonal_rod)
 {
 	 delta_tower1_x= -SIN_60*radius; // front left tower
@@ -3962,20 +3964,51 @@ void recalc_delta_settings(float radius,
 	 delta_diagonal_rod_2= sq(diagonal_rod);
 }
 
+int delta_calcAngleYZ(float x0, float y0, float zo, float& theta)
+
+{
+float y1 = -0.5 * 0.57735 * f; // f/2 * tg 30
+y0 -= 0.5 * 0.57735 * e; // shift center to edge
+// z = a + b*y
+float a = (x0*x0 + y0*y0 + z0*z0 +rf*rf - re*re - y1*y1)/(2*z0);
+float b = (y1-y0)/z0;
+// discriminant
+float d = -(a+b*y1)*(a+b*y1)+rf*(b*b*rf+rf);
+if (d < 0) return -1; // non-existing point
+float yj = (y1 - a*b - sqrt(d))/(b*b + 1); // choosing outer point
+float zj = a + b*yj;
+
+theta = 180.0*atan(-zj/(y1 - yj))/DELTA_PI + ((yj>y1)?180.0:0.0);
+
+return 0;
+
+}
+
 void calculate_delta(float cartesian[3])
 {
-  delta[X_AXIS] = sqrt(delta_diagonal_rod_2
-                       - sq(delta_tower1_x-cartesian[X_AXIS])
-                       - sq(delta_tower1_y-cartesian[Y_AXIS])
-                       ) + cartesian[Z_AXIS];
-  delta[Y_AXIS] = sqrt(delta_diagonal_rod_2
-                       - sq(delta_tower2_x-cartesian[X_AXIS])
-                       - sq(delta_tower2_y-cartesian[Y_AXIS])
-                       ) + cartesian[Z_AXIS];
-  delta[Z_AXIS] = sqrt(delta_diagonal_rod_2
-                       - sq(delta_tower3_x-cartesian[X_AXIS])
-                       - sq(delta_tower3_y-cartesian[Y_AXIS])
-                       ) + cartesian[Z_AXIS];
+// inverse kinematics: (x0, y0, z0) -> (theta1, theta2, theta3)
+// returned status: 0=OK, -1=non-existing position
+
+float theta1 = 0.0;
+float theta2 = 0.0;
+float theta3 = 0.0;
+
+x0 = cartesian[X_AXIS];
+y0 = cartesian[Y_AXIS];
+z0 = cartesian[Z_AXIS] - DELTA_HOME_POS;
+
+int status = delta_calcAngleYZ(x0, y0, z0, theta1);
+
+if (status == 0) status = delta_calcAngleYZ(x0*cos120 + y0*sin120, y0*cos120-x0*sin120, z0, theta2); // rotate coords to +120 deg
+
+if (status == 0) status = delta_calcAngleYZ(x0*cos120 - y0*sin120, y0*cos120+x0*sin120, z0, theta3); // rotate coords to -120 deg
+
+//not sure about the scaling here, needs work
+
+delta[X_AXIS] = -theta1;
+delta[Y_AXIS] = -theta2;
+delta[Z_AXIS] = -theta3;
+
   /*
   SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);
   SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);
@@ -3985,6 +4018,7 @@ void calculate_delta(float cartesian[3])
   SERIAL_ECHOPGM(" y="); SERIAL_ECHO(delta[Y_AXIS]);
   SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(delta[Z_AXIS]);
   */
+
 }
 #endif
 
diff -rupN ./Marlin/Marlin/Marlin.pde ./Marlin_latest_MOD/Marlin/Marlin.pde
--- ./Marlin/Marlin/Marlin.pde	2014-11-29 05:44:29.000000000 +1300
+++ ./Marlin_latest_MOD/Marlin/Marlin.pde	1970-01-01 12:00:00.000000000 +1200
@@ -1,56 +0,0 @@
-/* -*- c++ -*- */
-
-/*
-    Reprap firmware based on Sprinter and grbl.
- Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
-
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
-
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/*
- This firmware is a mashup between Sprinter and grbl.
-  (https://github.com/kliment/Sprinter)
-  (https://github.com/simen/grbl/tree)
-
- It has preliminary support for Matthew Roberts advance algorithm
-    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
- */
-
-/* All the implementation is done in *.cpp files to get better compatibility with avr-gcc without the Arduino IDE */
-/* Use this file to help the Arduino IDE find which Arduino libraries are needed and to keep documentation on GCode */
-
-#include "Configuration.h"
-#include "pins.h"
-
-#ifdef ULTRA_LCD
-  #if defined(LCD_I2C_TYPE_PCF8575)
-    #include <Wire.h>
-    #include <LiquidCrystal_I2C.h>
-  #elif defined(LCD_I2C_TYPE_MCP23017) || defined(LCD_I2C_TYPE_MCP23008)
-    #include <Wire.h>
-    #include <LiquidTWI2.h>
-  #elif defined(DOGLCD)
-    #include <U8glib.h> // library for graphics LCD by Oli Kraus (https://code.google.com/p/u8glib/)
-  #else
-    #include <LiquidCrystal.h> // library for character LCD
-  #endif
-#endif
-
-#if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
-#include <SPI.h>
-#endif
-
-#if defined(DIGIPOT_I2C)
-  #include <Wire.h>
-#endif
diff -rupN ./Marlin/Marlin/thermistortables.h ./Marlin_latest_MOD/Marlin/thermistortables.h
--- ./Marlin/Marlin/thermistortables.h	2014-11-29 05:44:29.000000000 +1300
+++ ./Marlin_latest_MOD/Marlin/thermistortables.h	2014-12-03 20:14:15.658346136 +1300
@@ -5,6 +5,7 @@
 
 #define OVERSAMPLENR 16
 
+
 #if (THERMISTORHEATER_0 == 1) || (THERMISTORHEATER_1 == 1)  || (THERMISTORHEATER_2 == 1) || (THERMISTORBED == 1) //100k bed thermistor
 
 const short temptable_1[][2] PROGMEM = {
diff -rupN ./Marlin/Marlin/ultralcd.cpp ./Marlin_latest_MOD/Marlin/ultralcd.cpp
--- ./Marlin/Marlin/ultralcd.cpp	2014-11-29 05:44:29.000000000 +1300
+++ ./Marlin_latest_MOD/Marlin/ultralcd.cpp	2014-11-17 02:57:31.000000000 +1300
@@ -162,8 +162,6 @@ bool lcd_oldcardstatus;
 menuFunc_t currentMenu = lcd_status_screen; /* function pointer to the currently active menu */
 uint32_t lcd_next_update_millis;
 uint8_t lcd_status_update_delay;
-bool ignore_click = false;
-bool wait_for_unclick;
 uint8_t lcdDrawUpdate = 2;                  /* Set to none-zero when the LCD needs to draw, decreased after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial) */
 
 //prevMenu and prevEncoderPosition are used to store the previous menu location when editing settings.
@@ -191,26 +189,7 @@ static void lcd_status_screen()
         lcd_status_update_delay = 10;   /* redraw the main screen every second. This is easier then trying keep track of all things that change on the screen */
     }
 #ifdef ULTIPANEL
-
-    bool current_click = LCD_CLICKED;
-
-    if (ignore_click) {
-        if (wait_for_unclick) {
-          if (!current_click) {
-              ignore_click = wait_for_unclick = false;
-          }
-          else {
-              current_click = false;
-          }
-        }
-        else if (current_click) {
-            lcd_quick_feedback();
-            wait_for_unclick = true;
-            current_click = false;
-        }
-    }
-
-    if (current_click)
+    if (LCD_CLICKED)
     {
         currentMenu = lcd_main_menu;
         encoderPosition = 0;
@@ -1336,12 +1315,6 @@ void lcd_update()
     }
 }
 
-void lcd_ignore_click(bool b)
-{
-    ignore_click = b;
-    wait_for_unclick = false;
-}
-
 void lcd_setstatus(const char* message)
 {
     if (lcd_status_message_level > 0)
diff -rupN ./Marlin/Marlin/ultralcd.h ./Marlin_latest_MOD/Marlin/ultralcd.h
--- ./Marlin/Marlin/ultralcd.h	2014-11-29 05:44:29.000000000 +1300
+++ ./Marlin_latest_MOD/Marlin/ultralcd.h	2014-11-17 02:57:31.000000000 +1300
@@ -48,8 +48,6 @@
   void lcd_buzz(long duration,uint16_t freq);
   bool lcd_clicked();
 
-  void lcd_ignore_click(bool b=true);
-
   #ifdef NEWPANEL
     #define EN_C (1<<BLEN_C)
     #define EN_B (1<<BLEN_B)
